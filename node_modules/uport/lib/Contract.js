'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Contract = exports.ContractFactory = undefined;

var _toConsumableArray2 = require('babel-runtime/helpers/toConsumableArray');

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _typeof2 = require('babel-runtime/helpers/typeof');

var _typeof3 = _interopRequireDefault(_typeof2);

var _mnid = require('mnid');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var arrayContainsArray = require('ethjs-util').arrayContainsArray;

// A derivative work of Nick Dodson's eths-contract https://github.com/ethjs/ethjs-contract/blob/master/src/index.js

var hasTransactionObject = function hasTransactionObject(args) {
  var txObjectProperties = ['from', 'to', 'data', 'value', 'gasPrice', 'gas'];
  if ((typeof args === 'undefined' ? 'undefined' : (0, _typeof3.default)(args)) === 'object' && Array.isArray(args) === true && args.length > 0) {
    if ((0, _typeof3.default)(args[args.length - 1]) === 'object' && ((0, _keys2.default)(args[args.length - 1]).length === 0 || arrayContainsArray((0, _keys2.default)(args[args.length - 1]), txObjectProperties, true))) {
      return true;
    }
  }

  return false;
};

var getCallableMethodsFromABI = function getCallableMethodsFromABI(contractABI) {
  return contractABI.filter(function (json) {
    return (json.type === 'function' || json.type === 'event') && json.name.length > 0;
  });
};

var encodeMethodReadable = function encodeMethodReadable(methodObject, methodArgs) {
  var dataString = methodObject.name + '(';

  for (var i = 0; i < methodObject.inputs.length; i++) {
    var input = methodObject.inputs[i];
    var argString = input.type + ' ';

    if (input.type === 'string') {
      argString += '\'' + methodArgs[i] + '\'';
    } else if (input.type === ('bytes32' || 'bytes')) {
      // TODO don't assume hex input? or throw error if not hex
      // argString += `0x${new Buffer(methodArgs[i], 'hex')}`
      argString += '' + methodArgs[i];
    } else {
      argString += '' + methodArgs[i];
    }

    dataString += argString;

    if (methodObject.inputs.length - 1 !== i) {
      dataString += ', ';
    }
  }
  return dataString += ')';
};

var ContractFactory = function ContractFactory(extend) {
  return function (contractABI) {
    var output = {};
    output.at = function atContract(address) {

      function Contract() {
        var self = this;
        self.abi = contractABI || [];
        self.address = address || '0x';

        getCallableMethodsFromABI(contractABI).forEach(function (methodObject) {
          self[methodObject.name] = function contractMethod() {

            if (methodObject.constant === true) {
              throw new Error('A call does not return the txobject, no transaction necessary.');
            }

            if (methodObject.type === 'event') {
              throw new Error('An event does not return the txobject, events not supported');
            }

            var providedTxObject = {};
            var methodArgs = [].slice.call(arguments);

            if (methodObject.type === 'function') {
              if (hasTransactionObject(methodArgs)) providedTxObject = methodArgs.pop();
              var methodTxObject = (0, _assign2.default)({}, providedTxObject, {
                to: self.address
              });

              methodTxObject.function = encodeMethodReadable(methodObject, methodArgs);

              if (!extend) return methodTxObject;

              var extendArgs = methodArgs.slice(methodObject.inputs.length);
              return extend.apply(undefined, [methodTxObject].concat((0, _toConsumableArray3.default)(extendArgs)));
            }
          };
        });
      }

      return new Contract();
    };

    return output;
  };
};

var buildRequestURI = function buildRequestURI(txObject) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      callbackUrl = _ref.callbackUrl,
      type = _ref.type;

  if (!(0, _mnid.isMNID)(txObject.to)) throw new Error('To address must be MNID');
  var uri = 'me.uport:' + txObject.to;

  var pairs = [];
  if (txObject.value) pairs.push(['value', parseInt(txObject.value, 16)]);
  if (txObject.function) pairs.push(['function', txObject.function]);
  if (callbackUrl) pairs.push(['callback_url', callbackUrl]);
  if (txObject.gasPrice) pairs.push(['gasPrice', txObject.gasPrice]);
  if (type) pairs.push(['type', type]);

  return uri + '?' + pairs.map(function (kv) {
    return kv[0] + '=' + encodeURIComponent(kv[1]);
  }).join('&');
};

var Contract = ContractFactory(buildRequestURI);

exports.ContractFactory = ContractFactory;
exports.Contract = Contract;